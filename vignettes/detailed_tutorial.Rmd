---
title: "Step-by-step guide to running OAR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Step-by-step guide to running OAR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(knitr)

hook_output <- knitr::knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
   lines <- options$output.lines
   if (is.null(lines)) {
     return(hook_output(x, options))  # pass to default hook
   }
   x <- unlist(strsplit(x, "\n"))
   more <- "..."
   if (length(lines)==1) {        # first n lines
     if (length(x) > lines) {
       # truncate the output, but add ....
       x <- c(head(x, lines), more)
     }
   } else {
     x <- c(more, x[lines], more)
   }
   # paste these lines together
   x <- paste(c(x, ""), collapse = "\n")
   hook_output(x, options)
 })

opts_chunk$set(eval=TRUE,
   ## text results
   echo=TRUE,
   results=c('markup', 'asis', 'hold', 'hide')[1],
   ## plots
   fig.path=c('figure', 'figure/minimal-')[1],
   fig.keep=c('high', 'none', 'all', 'first', 'last')[1],
   fig.align=c('center', 'left', 'right', 'default')[1],
   fig.show=c('hold', 'asis', 'animate', 'hide')[1],
   dev=c('pdf', 'png', 'tikz')[2],
   fig.width=5, fig.height=3, #inches
   fig.env=c('figure', 'marginfigure')[1],
   fig.pos=c('', 'h', 't', 'b', 'p', 'H')[1]
   )
```

```{r setup}
library(OAR)
```

# Overview

In this tutorial we will walk you through all the steps of generating and analyzing OAR scores from your single cell dataset. We will begin with a Seurat object with plasmacytoid dendritic cells that you can download from our [github repository](https://github.com/Sanin-Lab/OARscRNA/tree/main/vignettes).

The process starting from a gene expression matrix is very similar and you should be able to adapt this workflow to that input. Skip a few lines down to the **data pre-processing step** to run the tutorial that way.

At the end, we provide an alternative single line [wrapper function](wrapper-functions-and-result-interpretation) that runs the whole process, and adds the results to the `meta.data` slot of a Seurat object. If starting from a dataset with multiple cell types, we recommend running this process cluster by cluster, and similarly provide a wrapper function that accomplishes that.

## 1. Loading and pre-processing your data

First, we load a Seurat object that we wish examine and store the cell barcodes so we can later assign them to our output.

```{r load seurat object}
sc.data <- readRDS(file = "pdcs.rds")
cells = colnames(sc.data)
sc.data
```

Now lets set a count threshold where we only analyze genes expressed in at least 1% of cells[^1]. We do not recommend using thresholds higher than 2%, as information will be lost.

[^1]: *Filtering genes may reduce the time it takes to run the analysis.*

```{r set count threshold}
tr = 1
```

Next, we retrieve the un-normalized count data from the Seurat object, filter low abundance genes and remove genes that are uninformative[^2]. The output of this function is a list with the first element being the processed matrix and the second the list of genes in that matrix after filtering. We will skip the later for this tutorial. Missing values in the processed matrix of gene counts are denoted as `NA`.

[^2]: *Filtering genes may reduce the time it takes to run the analysis.*

```{r preprocess data, output.lines=5}
oar_data <- oar_preprocess_data(
  data = sc.data, tr = tr, 
  seurat_v5 = T, blacklisted.genes = NULL)
oar_data[[1]][1:5,1:5]
```

For a full description of each parameter consult the documentation. Briefly:

-   `seurat_v5` confirms the type of data being used. Defaults to `TRUE`. If **starting from a data matrix**, set this to `FALSE` and continue with the rest of the tutorial.
-   `tr` controls the minimum percentage of cells expressing any given gene for that gene to be retained in the analysis. Defaults to 1.
-   `blacklisted.genes` allows you to provide a vector of uninformative gene names (i.e. non-coding genes) to exclude from the analysis. Defaults to `NULL`.

## 2. Identifying Missing Data Patterns

Our scoring relies on identifying co-expressed genes patterns (which we call missing data patterns) which is a computationally intensive process. To do this, we can identify genes with minimal mismatch between them, but we need to first enable R to run in parallel. To determine your computers capacity, you can run `parallelly::availableCores()`. Leave at least 1-2 cores available for other processes running in your computer to prevent crashing. Using multiple cores is recommended as it will go much faster in the identification of the patterns.

```{r parallel cores, output.lines=5}
parallelly::availableCores()
```

Now we can select an appropriate number to set up parallel processing for this R session. To identify the missing data patterns allowing for mismatch, we calculate the hamming distance between all pairs of gene expression vectors. Internally, the gene vectors are converted to 0 (missing) and 1 (observed) values. This function needs to have the number of cores specified explicitly, and is the slowest portion of the analysis. 

```{r hamming distance calculation, output.lines=5}
dm <- oar_hamming_distance(
  oar_data[[1]], cores = 1)
dm[1:5,1:5]
```

The output is a matrix where the hamming distance between each pair of gene expression vectors is calculated. In the wrapper function `oar` you have the possibility of storing this result in your Seurat object, so that future score calculations are completed faster. The wrapper function automatically detects a previously calculated hamming distance matrix and uses that for further analysis. **WARNING: If you use a different count filter value, or a different set of cells, these distances will no longer be appropriate. In that case, remove previously calculated distance matrix using** `oar_obj[["RNA"]]@misc <- list()`.

Next, we want to group genes into co-expression patters based on a minimal hamming distance threshold, which we refer to as `tolerance`. This tolerance value is the fraction of mismatch between gene vectors that we allow to consider genes as part of the same pattern. To identify a suitable value between 0.01 and 0.05, we can set `tolerance` to `TRUE` in the `oar_missing_data_patterns` function. This function will search for a `tolerance` that does not introduce biases in the pattern matching. We have found that increasing `tolerance` can introduce an artificial relationship between the percentage of missing values and the significance test at the core of this approach. 

```{r mdp with automatic tolerance, output.lines=5}
mdp_auto_tol <- oar_missing_data_patterns(
  oar_data[[1]], dm, tolerance = T)
table(mdp_auto_tol)
```

**A few considerantions on tolerance setting:**
- Using a tolerance of 0 *(i.e. allowing only for exact matches)* results in very few, and often no, co-expressed gene patterns. This configuration generally fails and is not recommended.
- The automatic tolerance setting selects the minimum tolerance above 0 where the percentage of missing values in a cell is not predictive of the *observed at random* test. If you choose your own tolerance, it is recommended you plot those two variables against each other (`KW.BH.pvalue` vs. `pct.missing`) and fit a linear model. If the slope of the model is significant and negative, the tolerance setting might not be appropriate.

We can choose our own tolerance and pass it to the function, which will be faster. Values greater than 0 and lower than 0.05 are recommended.

```{r mdp with specific tolerance, output.lines=5, eval = FALSE}
oar_missing_data_patterns(oar_data[[1]], dm, tolerance = 0.05)
```

In this dataset a tolerance of 0.02 produced the best results, with 2 distinct patters found across cells (plus the combination of all genes with non-unique patterns). We can visualize these results like this:

```{r patterns_found_mdp, out.width="50%", fig.cap="Missing Data Pattern Plot"}
p3 <- oar_missing_data_plot(data = oar_data[[1]], mdp = mdp_auto_tol, seurat_v5 = FALSE)
p3
```

Each slice of the bar represents a cell, and it is colored based on what percentage of genes from that pattern are expressed in each cell.

## 3. Calculate OAR scores

Now we are ready to do a cell-wise estimation of the overlap between the gene expression distributions in each detected pattern. When these distributions are distinct, we find that the data is not missing at random (NOAR), with highly significant p values and an OAR score of less than 2. Alternatively, when these distributions overlap, gene expression appears more randomly distributed (OAR), and cells have a larger p value and an OAR score greater than 2. Critically, our test incorporates both the gene expression values and the missing data patterns.

```{r oar base, output.lines=5}
output <- oar_base(data = oar_data[[1]], mdp = mdp_auto_tol)
output$barcodes = cells #add back our barcodes
output
```

The result is a matrix with these columns:

-   `OARscore` is a metric of heterogeneity in the data, with a higher OAR score highlighting cells with gene expression patterns dissimilar from all others tested.
-   `KW.pvalue` is the p-value generated by Kruskal-Wallis test.
-   `KW.BH.pvalue` is the Benjamini-Hochberg corrected p-value.
-   `pct.missing` is the percent of missing genes in each cell as a fraction of all genes expressed by all cells in the dataset.

We can now proceed to visualize these results to identify which cells are most heterogeneous.

## 4. Visualize results

A higher OAR score is a way to prioritize cells for further analysis. Greater scores indicate distinct cell expression signatures, where high scoring cells have different gene co-expression patterns compared to all other cells in the test. In this example, we observe that cells with a high degree of sparsity, also have a high OAR score

```{r create_scatter_plot, out.width="100%", fig.cap="Scatter Plots"}
library(ggplot2)
p1 <-ggplot(
  data = output,
  aes(x = pct.missing,
      y = OARscore, 
      color = -log10(KW.BH.pvalue))) + 
  geom_point(size = 0.5) + 
  labs(
    x = "% Missing Data",
    y = "OAR score") +
  geom_hline(
    yintercept = 2, linetype = "dashed", 
    color = "black", linewidth = 0.25) +
  scale_colour_gradientn(
    colours = (c("#000004FF","#3B0F70FF","#8C2981FF",
                    "#DE4968FF", "#FE9F6DFF","#FCFDBFFF")),
    na.value = "transparent", 
    name = expression(-Log[10]~BH.pval),
    guide = guide_colorbar(
      frame.colour = "black",
      frame.linewidth = 0.2,
      ticks.linewidth = 0.2,
      ticks.colour = "black")) +
  theme(
    aspect.ratio = 1,
    panel.grid = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(linewidth = 0.5),
    legend.text = element_text(size = 6), 
    legend.title = element_text(size = 8),
    legend.key.size = unit(3, "mm"),
    axis.text = element_text(size = 6), 
    axis.title = element_text(size = 8),
    plot.title = element_blank())
p1
```

You may recreate this plot using `scatter_score_missing()`.

In order to fully understand the features in the dataset driving the high OAR score in some cells, it will be necessary to annotate these with their biological context. This is more easily achieved within a Seurat object with the additional experimental details.

## 5. Wrapper functions and result interpretation

We can run this entire process with a single line. The result is the Seurat object with the `OARscore`, `KW.pvalue`, `KW.BH.pvalue` and `pct.missing` values in the `meta.data` slot. Additionally, genes are annotated by which missing data patterns (mdp) they have been included in `sc.data@assays$RNA@meta.data`.

```{r oar wrapper, output.lines=5}
sc.data <- oar(data = sc.data, 
               seurat_v5 = T, count.filter = 1,
               blacklisted.genes = NULL, suffix = "",
               tolerance = 0.02, store.hamming = T,
               cores = 1)
```

We set these parameters based on our earlier results and adjusted to the data provided:

-   `seurat_v5` confirms the type of data being used. Defaults to `TRUE`.
-   `tolerance` controls whether the mismatch threshold should be determined automatically (between 0.01 and 0.05 hamming distances) or if a user supplied threshold should be used. Defaults to `TRUE`, and can take `TRUE` or a numeric value smaller than 1. Here we set it to 0.02 based on our results above.
-   `count.filter` controls the minimum percentage of cells expressing any given gene for that gene to be retained in the analysis. Defaults to 1.
-   `blacklisted.genes` Allows you to provide a vector of uninformative gene names (i.e. non-conding genes) to exclude from the analysis. Defaults to `NULL`.
-   `suffix` Allows you to provide a character string to avoid overwriting previous OAR calculations. Defaults to `NULL`.
-   `store.hamming` allows you to store the calculated hamming distances for pattern matching in your Seurat object for faster re-calculation of the scores if you need to alter other parameters later (found in `oar_obj[["RNA"]]@misc`). Defaults to `TRUE`.

You can use a similar approach to analyse the data cluster by cluster - recommended when you have multiple cell types. In that case, use `oar_by_cluster()`.

#### Interpreting high OAR scores

To explore which cells/clusters have the most heterogeneity, we can project the scores to our UMAP using `Seurat::FeaturePlot()`. Notice that cells with a high OAR score in this dataset cluster together. In fact, in this case, high OAR scoring cells represent the most activated cells in the experiment, as can be seen when we examine *IFNA1*, which is expressed in activated plasmacytoid dendritic cells.

```{r featureplot_score, out.width="100%", fig.cap="Feature plot of OAR score"}
library(Seurat)
p1 <- FeaturePlot(
  sc.data, features = c("OARscore","IFNA1"), order = T, pt.size = 0.5, 
  min.cutoff = "q40", max.cutoff = "q90", slot = "counts")
p1
```

Thus, in this dataset we are able to identify highly activated cells with a cluster agnostic approach. We provide additional tutorials to identify genes associated with a high OAR score (see: `vignette("Gene_expression")`). We have also seen datasets where high scores are associated with biological variation that may be removed from the analysis to glean additional insights into the populations of cells studied. These can be achieved by passing `OARscore` to `vars.to.regress` in `Seurat::SCTransform()`.
