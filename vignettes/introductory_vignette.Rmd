---
title: "introductory_vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introductory_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(knitr)

hook_output <- knitr::knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
   lines <- options$output.lines
   if (is.null(lines)) {
     return(hook_output(x, options))  # pass to default hook
   }
   x <- unlist(strsplit(x, "\n"))
   more <- "..."
   if (length(lines)==1) {        # first n lines
     if (length(x) > lines) {
       # truncate the output, but add ....
       x <- c(head(x, lines), more)
     }
   } else {
     x <- c(more, x[lines], more)
   }
   # paste these lines together
   x <- paste(c(x, ""), collapse = "\n")
   hook_output(x, options)
 })
```

```{r setup}
library(OAR)
```

```{r include=FALSE, echo=FALSE}
data_dir <- "/Users/hannahmoore/Documents/Immunology PhD/2024/Rotations/Sanin/OAR_package/OARscRNA/vignettes/"
```

# Introductory Vignette for OARscRNA

In this vignette we will walk you through the very basic steps of generating and analyzing OARscores from your single cell dataset.

There are two possible starting points:\
1. Seurat v5 Object\
2. Gene Expression Matrix\

## Starting from v5 Seurat Object

### Analysis

We can also directly input a Seurat object to examine heterogeneity.

```{r load seurat object}
data_obj <- readRDS(paste0(data_dir, "pdcs.rds"))
```

Once you have data loaded, you can run the oar function. This function requires the input data, as well as to be informed whether or not it is a v5 Seurat object.\
Next you can decide where or not to allow for some flexibility in pattern mismatch (mismatch = TRUE), and whether it should automatically determine best tolerance (tolerance = TRUE). You can also provide a numeric value to tolerance.\
This will go much faster if it is able to run some computation in parallel. To determine your computers capacity, you can run parallelly::availableCores(). Leave at least 1-2 cores available to prevent crashing.

```{r run oar on seurat object, output.lines=5}
oar_obj <- oar(data_obj, seurat_v5 = TRUE, mismatch = TRUE, tolerance = TRUE, cores = 2)
```

Since most of these are the defaults, you would get this same result with simply:

```{r run most basic oar, output.lines=5}
oar_obj <- oar(data_obj, cores = 2)
```

The result is the Seurat object with additional metadata. To the cells metadata (found in [oar_obj\@meta.data](mailto:oar_obj@meta.data){.email}) there will be the following additional columns:\
-OARscore: a metric of heterogeneity in the data, with a higher OAR score indicating that this cell shares less patterns in common than others.\
-KW.pvalue: P-value generated by Kruskal-Wallis test.\
-KW.BH.pvalue: Benjamini-Hochberg corrected p-value.\
-pct.missing: the percent of missing genes in that cell (of total genes expressed by cells in the experiment, how many are not being expressed in this cell).

Additionally, the genes have been annotated by which missing data patterns (mdp) they have been included in. This mdp matrix has been added to the assay metadata (found in [oar_obj\@assays](mailto:oar_obj@assays){.email}\$[RNA\@meta.data](mailto:RNA@meta.data){.email}).

### Analysis by Cluster

OARscores are typically more powerful when distinguishing amongst cells as the same type, as heterogeneity in gene patterns are likely from a biological phenomenon other than cell type. When working with a dataset with diverse cell types, it can be helpful to run the function by cluster.

```{r run oar by cluster, output.lines=5}
oar_obj_bycluster <- oar_by_cluster(data_obj, cores = 2)
```

### Visualize Results

There are several way to visualize your resulting seurat object:\
**OARscore v Percent Missing Scatter Plot**

```{r create scatter plot}
scatter_score_missing(oar_obj)
```

This plot reveals which clusters have the highest OAR scores, as well as how the OARscore correlates to the percent of missing values. Adjust the group.by metric to examine other variables:

```{r create scatter plot colored by condition}
scatter_score_missing(oar_obj, group.by = "condition")
```

**Graphic of Missing Data Patterns**\
Visualize patterns found by OAR:

```{r create visual of patterns found}
oar_missing_data_plot(oar_obj)
```

In this case we have a combination of all unique patterns, and 3 patterns found across cells, with the assigned indices of 9102, 6, and 3. Each slice of the bar represents a cell, and it is colored based on what percentage of genes from that pattern are expressed in each cell. For example, in pattern 9102, about half the cells have some of these 13 genes expressed.

To get a list of the highly variable genes withing each pattern, use:

```{r get list of genes involved in patterns}
mdp <- get_missing_pattern_genes(oar_obj)
```

**Seurat Feature Plot**\
To visualize which cells/clusters have the most heterogeneity:

```{r look at OAR score in featureplot}
library(Seurat)
FeaturePlot(oar_obj, features = "OARscore", order = T)
```

## Starting from a Gene Expression Matrix

Most functions in the package accept either a v5 Seurat object or a gene expression matrix as input. Here we will walk you through steps of the analysis, beginning with a gene expression matrix from pDC data that you can download from our [github](https://github.com/davidsanin/OARscRNA/tree/main/vignettes).

```{r load matrix}
data <- readRDS(paste0(data_dir,"pdcs_matrix.rds"))
```

### Analysis

Once you have data loaded, you can run the oar function. This function requires the input data, as well as to be informed whether or not it is a v5 Seurat object.\
Next you can decide where or not to allow for some flexibility in pattern mismatch (mismatch = TRUE), and whether it should automatically determine best tolerance (tolerance = TRUE). You can also provide a numeric value to tolerance.\
This will go much faster if it is able to run some computation in parallel. To determine your computers capacity, you can run parallelly::availableCores(). Leave at least 1-2 cores available to prevent crashing.

```{r run OAR on matrix, output.lines=5}
oar_data<- oar(data, seurat_v5 = FALSE, mismatch = TRUE, tolerance = TRUE, cores = 2)
```

This results in a table with the following columns:\
-OARscore: a metric of heterogeneity in the data, with a higher OAR score indicating that this cell shares less patterns in common than others.\
-KW.pvalue: P-value generated by Kruskal-Wallis test.\
-KW.BH.pvalue: Benjamini-Hochberg corrected p-value.\
-pct.missing: the percent of missing genes in that cell (of total genes expressed by cells in the experiment, how many are not being expressed in this cell).

```{r view results, output.lines=5}
oar_data
```

### Visualize Results

We can visualize these OARscores via scatter plot against the percent missing.

```{r scatter plot}
scatter_score_missing(oar_data, seurat_v5 = F)
```
