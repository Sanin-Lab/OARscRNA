.packages = c("OAR", "dplyr")) %dopar% {
# Replace 0 with NA
f.data[f.data == 0] <- NA
# Convert to a dense matrix
f.data <- as.matrix(f.data)
# store column names
cells = colnames(f.data)
colnames(f.data) = NULL
# data must be in .data.frame()
if (all(complete.cases(f.data))) {
stop("No missing data exists\n")
}
# Run test
w <- oarbase(data = f.data) %>%
dplyr::mutate(Fold = folds,
barcodes = cells)
return(w)
}
out <- oar_fold(pDCs)
warnings()
#Generate list of cell vectors for parallel or sequential processing
fold.data = list()
for(j in 1:iterations){
a = cell.names
for(i in 1:folds){
if(length(a) == 0) break
s <- paste0("iteration_",j,"_","fold_",i)
if(length(a) <= max.cells){max.cells = length(a)}
cells = sample(a,max.cells)
a = a[!a %chin% cells]
fold.data[[s]] = data[,colnames(data) %chin% cells]
}
}
print("Identifying missing patterns and scoring across folds...")
#parallel or sequential processing
if(parallel.loop){
#register cluster
my.cluster <- parallel::makeCluster(
cores,
type = "PSOCK"
)
doParallel::registerDoParallel(cl = my.cluster) #register it to be used by %dopar%
#Run the loop in parallel
output <- foreach::foreach(
f.data = fold.data,
folds = names(fold.data),
.verbose = F,
.packages = c("OAR", "dplyr")) %dopar% {
# Replace 0 with NA
f.data[f.data == 0] <- NA
# Convert to a dense matrix
f.data <- as.matrix(f.data)
# store column names
cells = colnames(f.data)
colnames(f.data) = NULL
# data must be in .data.frame()
if (all(complete.cases(f.data))) {
stop("No missing data exists\n")
}
# Run test
w <- oarbase(data = f.data) %>%
dplyr::mutate(Fold = folds,
barcodes = cells)
return(w)
}
parallel::stopCluster(cl = my.cluster)
}
fold.data = list()
for(j in 1:iterations){
a = cell.names
for(i in 1:folds){
if(length(a) == 0) break
s <- paste0("iteration_",j,"_","fold_",i)
if(length(a) <= max.cells){max.cells = length(a)}
cells = sample(a,max.cells)
a = a[!a %chin% cells]
fold.data[[s]] = data[,colnames(data) %chin% cells]
}
}
print("Identifying missing patterns and scoring across folds...")
#parallel or sequential processing
if(parallel.loop){
#register cluster
my.cluster <- parallel::makeCluster(
cores,
type = "PSOCK"
)
doParallel::registerDoParallel(cl = my.cluster) #register it to be used by %dopar%
#Run the loop in parallel
output <- foreach::foreach(
f.data = fold.data,
folds = names(fold.data),
.verbose = F,
.packages = c("OAR", "dplyr")) %dopar% {
# Replace 0 with NA
f.data[f.data == 0] <- NA
# Convert to a dense matrix
f.data <- as.matrix(f.data)
# store column names
cells = colnames(f.data)
colnames(f.data) = NULL
# data must be in .data.frame()
if (all(complete.cases(f.data))) {
stop("No missing data exists\n")
}
# Run test
w <- oarbase(data = f.data) %>%
dplyr::mutate(Fold = folds,
barcodes = cells)
return(w)
}
parallel::stopCluster(cl = my.cluster)
}
parallel.loop <- T
fold.data = list()
for(j in 1:iterations){
a = cell.names
for(i in 1:folds){
if(length(a) == 0) break
s <- paste0("iteration_",j,"_","fold_",i)
if(length(a) <= max.cells){max.cells = length(a)}
cells = sample(a,max.cells)
a = a[!a %chin% cells]
fold.data[[s]] = data[,colnames(data) %chin% cells]
}
}
print("Identifying missing patterns and scoring across folds...")
#parallel or sequential processing
if(parallel.loop){
#register cluster
my.cluster <- parallel::makeCluster(
cores,
type = "PSOCK"
)
doParallel::registerDoParallel(cl = my.cluster) #register it to be used by %dopar%
#Run the loop in parallel
output <- foreach::foreach(
f.data = fold.data,
folds = names(fold.data),
.verbose = F,
.packages = c("OAR", "dplyr")) %dopar% {
# Replace 0 with NA
f.data[f.data == 0] <- NA
# Convert to a dense matrix
f.data <- as.matrix(f.data)
# store column names
cells = colnames(f.data)
colnames(f.data) = NULL
# data must be in .data.frame()
if (all(complete.cases(f.data))) {
stop("No missing data exists\n")
}
# Run test
w <- oarbase(data = f.data) %>%
dplyr::mutate(Fold = folds,
barcodes = cells)
return(w)
}
parallel::stopCluster(cl = my.cluster)
}
cores = 1
fold.data = list()
for(j in 1:iterations){
a = cell.names
for(i in 1:folds){
if(length(a) == 0) break
s <- paste0("iteration_",j,"_","fold_",i)
if(length(a) <= max.cells){max.cells = length(a)}
cells = sample(a,max.cells)
a = a[!a %chin% cells]
fold.data[[s]] = data[,colnames(data) %chin% cells]
}
}
print("Identifying missing patterns and scoring across folds...")
#parallel or sequential processing
if(parallel.loop){
#register cluster
my.cluster <- parallel::makeCluster(
cores,
type = "PSOCK"
)
doParallel::registerDoParallel(cl = my.cluster) #register it to be used by %dopar%
#Run the loop in parallel
output <- foreach::foreach(
f.data = fold.data,
folds = names(fold.data),
.verbose = F,
.packages = c("OAR", "dplyr")) %dopar% {
# Replace 0 with NA
f.data[f.data == 0] <- NA
# Convert to a dense matrix
f.data <- as.matrix(f.data)
# store column names
cells = colnames(f.data)
colnames(f.data) = NULL
# data must be in .data.frame()
if (all(complete.cases(f.data))) {
stop("No missing data exists\n")
}
# Run test
w <- oarbase(data = f.data) %>%
dplyr::mutate(Fold = folds,
barcodes = cells)
return(w)
}
parallel::stopCluster(cl = my.cluster)
}
outs <- oar_fold(pDCs, cores = 1)
outs <- oar_fold(pDCs, cores = 1)
use_r("dummy_oar")
document()
load_all
load_all()
load_all()
warnings()
out_test <- dummy_oar(pDCs, fold.data = fold.data)
?foreach
usethis::use_import_from("foreach", "%dopar%")
load_all()
out_test <- dummy_oar(pDCs)
pDCs <- readRDS("~/OneDrive - Johns Hopkins/MissingData/Paper/data/pDCs.rds")
load_all()
outs <- dummy_oar(pDCs, cores = 2)
load_all()
outs <- dummy_oar(pDCs, cores = 2)
outs_test <- oar_fold(pDCs, cores = 2)
outs_test <- dummy_oar(pDCs, cores = 2)
pDCs <- readRDS("~/OneDrive - Johns Hopkins/MissingData/Paper/data/pDCs.rds")
outs_test <- dummy_oar(pDCs, cores = 2)
outs_test <- dummy_oar(pDCs, cores = 2)
load_all()
outs_test <- dummy_oar(pDCs, cores = 2)
load_all()
outs_test <- dummy_oar(pDCs, cores = 2)
load_all()
load_all*
load_all()
pDCs <- readRDS("~/OneDrive - Johns Hopkins/MissingData/Paper/data/pDCs.rds")
outs <- oar_fold(pDCs, cores = 2)
document()
check()
document()
deg <- oardeg(pDCs)
deg <- oardeg(outs)
document()
load_all()
outs <- oar_fold(pDCs, cores = 2)
load_all()
outs <- oar_fold(pDCs, cores = 2)
install()
outs <- oar_fold(pDCs, cores = 2)
load_all()
outs <- oar_fold(pDCs, cores = 2)
outs <- oar_fold(pDCs, cores = 2)
load_all()
outs <- oar_fold(pDCs, cores = 2)
document()
check()
usethis::use_import_from("stats", "kruskal.test")
document()
load_all()
pDCs <- readRDS("~/OneDrive - Johns Hopkins/MissingData/Paper/data/pDCs.rds")
degs <- oar_deg(pDCs)
degs <- oar_deg(outs, ncores = 2)
count.filter <- 1
degrees.freedom <- 5
cores = 2
score.name <- "OARscore"
traceback()
if(seurat_v5){
if(!sum(colnames(data@meta.data) %chin% score.name) == 1){
stop("OARscore column not present, or repeated, in the Seurat object. Have you run OARfold?\n")
}
layersList <- lapply(data@assays$RNA@layers,function(x){dim(x)}) #Identify empty layers
data@assays$RNA@layers[names(layersList[sapply(layersList, is.null)])] <- NULL #remove empty layers
if(length(layersList) >3){
print("Data may contain multiple raw count layers")
print("Joining data layers (time consuming!!) and extracting count tables")
}else{
print("Extracting count tables")}
dt <- SeuratObject::JoinLayers(object = data, assay = "RNA") %>%
SeuratObject::LayerData(assay = "RNA", layer = "counts") %>% #Extract count matrix
as.matrix() %>%
as.data.frame() %>%
rownames_to_column("gene_id")
if(length(blacklisted.genes) > 0 && is.character(blacklisted.genes)){
dt <- dt %>%
filter(!gene_id %chin% blacklisted.genes)
}
dt <- dt %>%
filter(!grepl("RPL",gene_id),
!grepl("Rpl",gene_id),
!grepl("rpl",gene_id),
!grepl("RPS",gene_id),
!grepl("Rps",gene_id),
!grepl("rps",gene_id))
tr = count.filter/100
dt <- dt[Matrix::rowSums(dt[,-1]) > dim(dt)[[2]]*tr,]
rownames(dt) <- dt$gene_id
dt <- dt[,-1]
df <- data@meta.data %>% #Prepare count metadata with residuals as the only information
dplyr::mutate(ID = rownames(.)) %>%
dplyr::select("ID", score.name)
}else{
dt <- data %>%
rownames_to_column("gene_id")
if(length(blacklisted.genes) > 0 && is.character(blacklisted.genes)){
dt <- dt %>%
filter(!gene_id %chin% blacklisted.genes)
}
dt <- dt %>%
filter(!grepl("RPL",gene_id),
!grepl("Rpl",gene_id),
!grepl("rpl",gene_id),
!grepl("RPS",gene_id),
!grepl("Rps",gene_id),
!grepl("rps",gene_id))
tr = count.filter/100
dt <- dt[Matrix::rowSums(dt[,-1]) > dim(dt)[[2]]*tr,]
rownames(dt) <- dt$gene_id
dt <- dt[,-1]
df <- data.frame(
"ID" = names(score),
score.name = score)
}
seurat_v5 <- T
if(seurat_v5){
if(!sum(colnames(data@meta.data) %chin% score.name) == 1){
stop("OARscore column not present, or repeated, in the Seurat object. Have you run OARfold?\n")
}
layersList <- lapply(data@assays$RNA@layers,function(x){dim(x)}) #Identify empty layers
data@assays$RNA@layers[names(layersList[sapply(layersList, is.null)])] <- NULL #remove empty layers
if(length(layersList) >3){
print("Data may contain multiple raw count layers")
print("Joining data layers (time consuming!!) and extracting count tables")
}else{
print("Extracting count tables")}
dt <- SeuratObject::JoinLayers(object = data, assay = "RNA") %>%
SeuratObject::LayerData(assay = "RNA", layer = "counts") %>% #Extract count matrix
as.matrix() %>%
as.data.frame() %>%
rownames_to_column("gene_id")
if(length(blacklisted.genes) > 0 && is.character(blacklisted.genes)){
dt <- dt %>%
filter(!gene_id %chin% blacklisted.genes)
}
dt <- dt %>%
filter(!grepl("RPL",gene_id),
!grepl("Rpl",gene_id),
!grepl("rpl",gene_id),
!grepl("RPS",gene_id),
!grepl("Rps",gene_id),
!grepl("rps",gene_id))
tr = count.filter/100
dt <- dt[Matrix::rowSums(dt[,-1]) > dim(dt)[[2]]*tr,]
rownames(dt) <- dt$gene_id
dt <- dt[,-1]
df <- data@meta.data %>% #Prepare count metadata with residuals as the only information
dplyr::mutate(ID = rownames(.)) %>%
dplyr::select("ID", score.name)
}else{
dt <- data %>%
rownames_to_column("gene_id")
if(length(blacklisted.genes) > 0 && is.character(blacklisted.genes)){
dt <- dt %>%
filter(!gene_id %chin% blacklisted.genes)
}
dt <- dt %>%
filter(!grepl("RPL",gene_id),
!grepl("Rpl",gene_id),
!grepl("rpl",gene_id),
!grepl("RPS",gene_id),
!grepl("Rps",gene_id),
!grepl("rps",gene_id))
tr = count.filter/100
dt <- dt[Matrix::rowSums(dt[,-1]) > dim(dt)[[2]]*tr,]
rownames(dt) <- dt$gene_id
dt <- dt[,-1]
df <- data.frame(
"ID" = names(score),
score.name = score)
}
degs <- oar_deg(outs, ncores = 2)
?model.matrix
tr = count.filter/100
if(seurat_v5){
if(!sum(colnames(data@meta.data) %chin% score.name) == 1){
stop("OARscore column not present, or repeated, in the Seurat object. Have you run OARfold?\n")
}
layersList <- lapply(data@assays$RNA@layers,function(x){dim(x)}) #Identify empty layers
data@assays$RNA@layers[names(layersList[sapply(layersList, is.null)])] <- NULL #remove empty layers
if(length(layersList) >3){
print("Data may contain multiple raw count layers")
print("Joining data layers (time consuming!!) and extracting count tables")
}else{
print("Extracting count tables")}
if(seurat_v5){
if(!sum(colnames(data@meta.data) %chin% score.name) == 1){
stop("OARscore column not present, or repeated, in the Seurat object. Have you run OARfold?\n")
}
layersList <- lapply(data@assays$RNA@layers,function(x){dim(x)}) #Identify empty layers
data@assays$RNA@layers[names(layersList[sapply(layersList, is.null)])] <- NULL #remove empty layers
if(length(layersList) >3){
print("Data may contain multiple raw count layers")
print("Joining data layers (time consuming!!) and extracting count tables")
}else{
print("Extracting count tables")}
dt <- SeuratObject::JoinLayers(object = data, assay = "RNA") %>%
SeuratObject::LayerData(assay = "RNA", layer = "counts") %>% #Extract count matrix
as.matrix() %>%
as.data.frame() %>%
rownames_to_column("gene_id")
if(length(blacklisted.genes) > 0 && is.character(blacklisted.genes)){
dt <- dt %>%
filter(!gene_id %chin% blacklisted.genes)
}
dt <- dt %>%
filter(!grepl("RPL",gene_id),
!grepl("Rpl",gene_id),
!grepl("rpl",gene_id),
!grepl("RPS",gene_id),
!grepl("Rps",gene_id),
!grepl("rps",gene_id))
tr = count.filter/100
dt <- dt[Matrix::rowSums(dt[,-1]) > dim(dt)[[2]]*tr,]
rownames(dt) <- dt$gene_id
dt <- dt[,-1]
df <- data@meta.data %>% #Prepare count metadata with residuals as the only information
dplyr::mutate(ID = rownames(.)) %>%
dplyr::select("ID", score.name)
}else{
dt <- data %>%
rownames_to_column("gene_id")
if(length(blacklisted.genes) > 0 && is.character(blacklisted.genes)){
dt <- dt %>%
filter(!gene_id %chin% blacklisted.genes)
}
}
if(!sum(colnames(data@meta.data) %chin% score.name) == 1){
stop("OARscore column not present, or repeated, in the Seurat object. Have you run OARfold?\n")
}
data <- pDCs
layersList <- lapply(data@assays$RNA@layers,function(x){dim(x)}) #Identify empty layers
data@assays$RNA@layers[names(layersList[sapply(layersList, is.null)])] <- NULL #remove empty layers
if(length(layersList) >3){
print("Data may contain multiple raw count layers")
print("Joining data layers (time consuming!!) and extracting count tables")
}else{
print("Extracting count tables")}
dt <- SeuratObject::JoinLayers(object = data, assay = "RNA") %>%
SeuratObject::LayerData(assay = "RNA", layer = "counts") %>% #Extract count matrix
as.matrix() %>%
as.data.frame() %>%
rownames_to_column("gene_id")
dt <- dt %>%
filter(!grepl("RPL",gene_id),
!grepl("Rpl",gene_id),
!grepl("rpl",gene_id),
!grepl("RPS",gene_id),
!grepl("Rps",gene_id),
!grepl("rps",gene_id))
dt <- dt[Matrix::rowSums(dt[,-1]) > dim(dt)[[2]]*tr,]
rownames(dt) <- dt$gene_id
dt <- dt[,-1]
df <- data@meta.data %>% #Prepare count metadata with residuals as the only information
dplyr::mutate(ID = rownames(.)) %>%
dplyr::select("ID", score.name)
data <- outs
layersList <- lapply(data@assays$RNA@layers,function(x){dim(x)}) #Identify empty layers
data@assays$RNA@layers[names(layersList[sapply(layersList, is.null)])] <- NULL #remove empty layers
dt <- SeuratObject::JoinLayers(object = data, assay = "RNA") %>%
SeuratObject::LayerData(assay = "RNA", layer = "counts") %>% #Extract count matrix
as.matrix() %>%
as.data.frame() %>%
rownames_to_column("gene_id")
dt <- dt %>%
filter(!grepl("RPL",gene_id),
!grepl("Rpl",gene_id),
!grepl("rpl",gene_id),
!grepl("RPS",gene_id),
!grepl("Rps",gene_id),
!grepl("rps",gene_id))
tr = count.filter/100
dt <- dt[Matrix::rowSums(dt[,-1]) > dim(dt)[[2]]*tr,]
rownames(dt) <- dt$gene_id
dt <- dt[,-1]
df <- data@meta.data %>% #Prepare count metadata with residuals as the only information
dplyr::mutate(ID = rownames(.)) %>%
dplyr::select("ID", score.name)
X <- splines::ns(df$score.name, df = degrees.freedom) # Any df between 3 - 5 usually works well.
?ns
df$OARscore
dim(df$OARscore)
X <- splines::ns(df$score.name, df = degrees.freedom) # Any df between 3 - 5 usually works well.
traceback()
?splineDesign
outs <- oar_fold(pDCs, cores = 2)
View(pDCs)
X <- splines::ns(df$score.name, df = degrees.freedom) # Any df between 3 - 5 usually works well.
outs <- oar_fold <- pDCs
rm(outs)
rm(oar_fold)
rm(pDCs)
outs <- oar_fold(pDCs, cores = 2)
pDCs <- readRDS("~/OneDrive - Johns Hopkins/MissingData/Paper/data/pDCs.rds")
outs <- oar_fold(pDCs, cores = 2)
X <- splines::ns(df$score.name, df = degrees.freedom) # Any df between 3 - 5 usually works well.
load_all()
View(df)
load_all()
load_all()
degs <- oar_deg(outs, cores = 2)
